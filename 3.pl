% Вариант 23. Задание: Найти все кратчайшие маршруты коня между двумя заданными позициями.

% Проверка, что позиция внутри доски 8x8
valid_pos(X,Y) :-
    between(1,8,X),
    between(1,8,Y).

move((X, Y), (X1, Y1)) :-
    member(DX-DY, [2-1, 2-(-1), -2-1, -2-(-1), 1-2, 1-(-2), -1-2, -1-(-2)]),
    X1 is X + DX,
    Y1 is Y + DY,
    valid_pos(X1, Y1).

% Путь коня длины L из Start в End, Path - список клеток [Start, ..., End]
path(Start, End, L, Path) :-
    path(Start, End, L, [Start], RevPath),
    reverse(RevPath, Path).

% Базовый случай: путь длины 0, начальная и конечная позиции совпадают
path(Pos, Pos, 0, Visited, Visited).

% Рекурсивный случай: путь длины L, ход конём, без повторных посещений
% ---------------------------
% Первый, неоптимизированный вариант path:
% Реализован без запрета на повторные посещения клеток (позволяет циклы)
% Трудоемкость: очень высокая, так как алгоритм может посещать одну и ту же клетку множество раз,
% что приводит к росту числа путей, особенно при больших длинах путей.
% Это вызывает огромную избыточность, множество циклов и сильно увеличивает время поиска.

% path(Pos, Pos, 0, Visited, Visited).
% path(Pos, End, L, Visited, Path) :-
%    L > 0,
%    move(Pos, Next),
%    L1 is L - 1,
%    path(Next, End, L1, [Next|Visited], Path).
% ---------------------------

% ---------------------------
% Второй, оптимизированный вариант path:
% Запрещаем повторные посещения клеток с помощью условия \+ member(Next, Visited).
% Это существенно сокращает пространство поиска, так как каждый путь 
% рассматривает только уникальные позиции, предотвращая циклы.
% Таким образом, уменьшается количество ветвлений и рекурсивных вызовов,
% что ведёт к снижению времени работы и памяти.
% На практике эта оптимизация даёт примерно двукратное ускорение в данной задаче.

% Итог: оптимизация снижает трудоемкость с большого количества путей с повторами
% до гораздо меньшего числа уникальных путей без циклов.
path(Pos, End, L, Visited, Path) :-
    L > 0,
    move(Pos, Next),
    \+ member(Next, Visited),
    L1 is L - 1,
    path(Next, End, L1, [Next|Visited], Path).
% ---------------------------

% Поиск всех кратчайших путей коня из Start в End
shortest_paths(Start, End, Paths) :-
    between(0, 63, L),
    findall(P, path(Start, End, L, P), Paths),
    Paths \= [], !.

% Функция вывода списка путей
print_paths([]).
print_paths([P|Ps]) :-
    write(P), nl,
    print_paths(Ps).

% Запуск поиска и вывода
run_and_print :-
    shortest_paths((1,1),(8,8), Paths),
    print_paths(Paths).

% Время выполнения работы до оптимизации:
% 211,446 inferences, 0.016 CPU in 2.017 seconds (1% CPU, 13532544 Lips)
% 211,446 inferences, 0.031 CPU in 2.125 seconds (1% CPU, 6766272 Lips)
% 211,446 inferences, 0.031 CPU in 2.019 seconds (2% CPU, 6766272 Lips)

% Время выполнения работы после оптимизации:
% 196,814 inferences, 0.047 CPU in 1.012 seconds (5% CPU, 4198699 Lips)
% 196,814 inferences, 0.031 CPU in 1.123 seconds (3% CPU, 6298048 Lips)
% 196,814 inferences, 0.016 CPU in 1.081 seconds (1% CPU, 12596096 Lips)


